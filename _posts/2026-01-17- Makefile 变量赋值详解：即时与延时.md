---
title: Makefile 变量赋值详解：即时与延时
date: 2026-01-17 10:00:00 +0800
categories: [linux,makefile]
tags: [linux]
layout: post  
---

# 📝 Makefile 变量赋值详解：即时与延时

在 Makefile 中，变量的定义不仅仅是存储一个字符串，它还决定了**求值的时间点**。这在交叉编译（Cross-Compilation）环境中至关重要。

## 1. 延时变量 (Recursively Expanded Variable) ⏳

- **符号**：`=`
- **特性**：**在使用时才求值**。`make` 会在整个 Makefile 解析完毕后，根据变量最后一次定义的值来执行。
- **应用场景**：当你需要引用在后面定义的变量，或者希望变量能感知全局变化时。

Makefile

```
# 示例
A = $(B)
B = hello
# 执行结果：A 的值是 "hello"
```

## 2. 即时变量 (Simply Expanded Variable) 📸

- **符号**：`:=`
- **特性**：**在定义时立即求值**。就像拍了一张“快照”，它只使用当前行之前已经存在的值。
- **应用场景**：嵌入式开发中最常用的方式，用于固定编译器路径（CC）、标志位（CFLAGS），避免后期被意外修改。

Makefile

```
# 示例
X := $(Y)
Y := world
# 执行结果：X 的值是 "" (空)，因为定义 X 时 Y 还没被赋值
```

## 3. 其他常用赋值符号 🛠️

| **符号** | **名称** | **功能描述**                                                 |
| -------- | -------- | ------------------------------------------------------------ |
| **`?=`** | 条件赋值 | 如果变量**尚未定义**，则赋值；若已定义（如命令行传入），则忽略。 |
| **`+=`** | 追加赋值 | 在现有变量内容的末尾**增加**新内容（自动添加空格）。         |

## 4. 嵌入式开发实战对比 🏗️

### 场景：切换交叉编译器

假设我们在 Makefile 的不同位置定义了 `CROSS_COMPILE`：

- **使用 `:=` (推荐)**：

  Makefile

  ```
  CC := $(CROSS_COMPILE)gcc  # 假设此时 CROSS_COMPILE 为 arm-linux-
  # CC 永久固定为 arm-linux-gcc，不受后续修改影响
  ```

- **使用 `=` (有风险)**：

  Makefile

  ```
  CC = $(CROSS_COMPILE)gcc
  # 若后面某处 CROSS_COMPILE 被改成了 riscv64-，
  # 那么执行编译时，CC 会变成 riscv64-gcc，导致平台错误。
  ```

------

这份笔记可以帮助你随时回顾。回到你刚才提到的那个问题：