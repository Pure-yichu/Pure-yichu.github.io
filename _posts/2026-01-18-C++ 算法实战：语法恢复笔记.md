---
title: C++ 算法实战：语法恢复笔记
date: 2026-01-17 10:00:00 +0800
categories: [[hello-algo,C++,STL]
tags: [hello-algo]
layout: post  
---
# C++ 算法实战：语法恢复笔记

## 一、 核心基础与内存管理

在算法实现中，性能（时间）和内存（空间）是核心。

### 1. 传参方式：性能的关键

- **值传递 (`void func(vector<int> v)`)**: 会复制整个容器，产生 $O(n)$ 额外开销，且函数内修改不影响原数据。
- **引用传递 (`void func(vector<int>& v)`)**: 不产生副本，效率高。直接操作原数据。
- **常量引用 (`void func(const vector<int>& v)`)**: **算法题中最推荐的只读传参方式**。既保证了不产生副本，又防止意外修改数据。

### 2. 结构体 (struct) 与 动态内存

用于定义链表、树等非线性结构。

- **自引用结构体**: 成员包含指向同类型实体的指针。
- **初始化列表**: 推荐使用这种方式给成员赋初值。
- **内存配对**:
  - `new` / `delete`: 单个对象。
  - `new[]` / `delete[]`: 数组。
  - **注意**: 指针访问成员使用 `->`。

C++

```c++
struct Node {
    int val;
    Node* next;
    // 初始化列表构造函数
    Node(int x) : val(x), next(nullptr) {} 
};
```

------

## 二、 序列容器 (Sequence Containers)

### 1. vector (动态数组)

- **特点**: 支持快速随机访问 $O(1)$。

- **操作**: `push_back()`, `size()`, `empty()`, `clear()`。

- **遍历**:

  C++

  ```c++
  for (int &x : nums) x *= 2; // 使用引用来修改原数组元素
  ```

### 2. deque (双端队列)

- **特点**: 头尾两端插入/删除均为 $O(1)$。
- **特有操作**: `push_front()`, `pop_front()`。

------

## 三、 容器适配器 (Stack & Queue)

主要用于搜索算法（DFS/BFS）。

| **容器**         | **特点**        | **访问函数** | **弹出函数** |
| ---------------- | --------------- | ------------ | ------------ |
| **stack (栈)**   | LIFO (后进先出) | `s.top()`    | `s.pop()`    |
| **queue (队列)** | FIFO (先进先出) | `q.front()`  | `q.pop()`    |

> **安全规范**: 在调用 `top()`、`front()` 或 `pop()` 前，务必先用 `!empty()` 检查容器是否为空，防止段错误。

------

## 四、 关联容器 (Maps & Sets)

用于去重、排序或建立索引。

### 1. set (集合)

- `set<int>`: 自动排序（升序）且去重。
- `unordered_set<int>`: 不排序，但插入/查找极快 ($O(1)$)。

### 2. map (映射)

- 存储 `{Key: Value}` 键值对。
- **语法糖**: `m[key]++` 常用于频率统计。
- **检查存在**: `if (m.count(key))` 或 `if (m.find(key) != m.end())`。

------

## 五、 算法库与迭代器 (Algorithm & Iterators)

### 1. 迭代器

- **左闭右开**: `[v.begin(), v.end())`。`end()` 永远指向末尾元素的下一个位置。

### 2. 常用函数

- **排序**: `sort(v.begin(), v.end(), cmp)`。
  - 降序: `greater<int>()` 或 Lambda `[](int a, int b){ return a > b; }`。
- **二分查找 (前提是有序)**:
  - `lower_bound`: 返回第一个 $\ge$ 目标值的迭代器。
  - `upper_bound`: 返回第一个 $>$ 目标值的迭代器。
  - **下标获取**: `auto index = lower_bound(...) - v.begin();`

------

## 💡 算法避坑指南

1. **越界检查**: 使用 `vector` 下标或指针 `->` 访问前，先行判定索引有效性。
2. **STL Pop**: `pop()` 函数不返回元素值，必须先访问（`top/front`）再弹出。
3. **时间复杂度**: 优先使用 `unordered_map` 代替 `map` 以获得平均 $O(1)$ 的性能，除非题目明确需要有序。