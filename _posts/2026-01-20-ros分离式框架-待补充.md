---
title: Ros主从框架
date: 2026-01-20 8:00:00 +0800
categories: [ros]
tags: [ros,c++]
layout: post  
---
# ROS 1 高阶节点开发模版：多阶段异步控制

## 1. 项目文件结构建议

一个规范的 ROS 包通常如下组织：

- `my_robot_control/`
  - `include/my_robot_control/task_manager.h` (类声明)
  - `src/task_manager.cpp` (类实现)
  - `src/main_node.cpp` (程序入口)
  - `srv/StageTrigger.srv` (自定义服务，包含一个 `string` 类型的 `cmd`)
  - `CMakeLists.txt`

------

## 2. 代码实现

### A. 头文件 (`task_manager.h`)

负责声明类结构、同步原语和状态机。

```c++
#ifndef TASK_MANAGER_H
#define TASK_MANAGER_H

#include <ros/ros.h>
#include <std_srvs/Trigger.h>
#include <mutex>
#include <condition_variable>
#include <string>

class TaskManager {
public:
    enum class TaskState { IDLE, STAGE1, STAGE2, FINISHED };

    TaskManager(ros::NodeHandle& nh);
    ~TaskManager() = default;

    // 执行主流程（将在主线程运行）
    void executeWorkflow();

private:
    // 服务回调
    bool stage1Callback(std_srvs::Trigger::Request &req, std_srvs::Trigger::Response &res);
    bool stage2Callback(std_srvs::Trigger::Request &req, std_srvs::Trigger::Response &res);

    ros::NodeHandle nh_;
    ros::ServiceServer srv_stage1_;
    ros::ServiceServer srv_stage2_;

    // 状态与同步原语
    TaskState current_state_;
    std::mutex mtx_;
    std::condition_variable cv_stage1_;
    bool stage1_triggered_ = false;

    std::condition_variable cv_stage2_;
    bool stage2_triggered_ = false;
};

#endif
```

------

### B. 源文件 (`task_manager.cpp`)

实现业务逻辑，展示 `Lambda` 和 `unique_lock` 的用法。

```c++
#include "my_robot_control/task_manager.h"

TaskManager::TaskManager(ros::NodeHandle& nh) : nh_(nh), current_state_(TaskState::IDLE) {
    srv_stage1_ = nh_.advertiseService("trigger_stage1", &TaskManager::stage1Callback, this);
    srv_stage2_ = nh_.advertiseService("trigger_stage2", &TaskManager::stage2Callback, this);
}

bool TaskManager::stage1Callback(std_srvs::Trigger::Request &req, std_srvs::Trigger::Response &res) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        stage1_triggered_ = true;
        current_state_ = TaskState::STAGE1;
    }
    cv_stage1_.notify_one(); 
    res.success = true;
    res.message = "Stage 1 Signal Received";
    return true;
}

bool TaskManager::stage2Callback(std_srvs::Trigger::Request &req, std_srvs::Trigger::Response &res) {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        stage2_triggered_ = true;
        current_state_ = TaskState::STAGE2;
    }
    cv_stage2_.notify_one();
    res.success = true;
    return true;
}

void TaskManager::executeWorkflow() {
    // 示例：使用 Lambda 定义一个内部规划辅助工具
    auto plan_task = [&](const std::string& name) {
        ROS_INFO("Planning for task: %s ...", name.c_str());
        ros::Duration(1.0).sleep(); // 模拟耗时规划过程
    };

    // --- 阶段 1 阻塞等待 ---
    ROS_INFO("Waiting for Service: Trigger Stage 1...");
    std::unique_lock<std::mutex> lk(mtx_);
    cv_stage1_.wait(lk, [this]{ return stage1_triggered_; });
    
    // 执行阶段 1 任务
    plan_task("Movement to Object");
    ROS_INFO("Stage 1 Action Executed.");
    lk.unlock(); // 任务处理完手动解锁

    // --- 阶段 2 阻塞等待 ---
    ROS_INFO("Waiting for Service: Trigger Stage 2...");
    lk.lock(); // 重新加锁准备下一次等待
    cv_stage2_.wait(lk, [this]{ return stage2_triggered_; });
    
    plan_task("Grasping Object");
    ROS_INFO("Stage 2 Action Executed. All Done.");
}
```

------

### C. 入口文件 (`main_node.cpp`)

配置异步旋转器并启动。

C++

```c++
#include "my_robot_control/task_manager.h"

int main(int argc, char** argv) {
    ros::init(argc, argv, "task_manager_node");
    ros::NodeHandle nh;

    // 1. 实例化类
    TaskManager manager(nh);

    // 2. 开启异步旋转器 (6个线程)
    // 这保证了主线程阻塞在 executeWorkflow 时，回调函数依然能被处理
    ros::AsyncSpinner spinner(6);
    spinner.start();

    // 3. 执行主逻辑（这会发生阻塞）
    manager.executeWorkflow();

    ros::waitForShutdown();
    return 0;
}
```

------

### D. 构建配置 (`CMakeLists.txt`)

关键在于将所有 `.cpp` 文件编译进同一个可执行文件。

```cmake
cmake_minimum_required(VERSION 3.0.2)
project(my_robot_control)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
  std_srvs
)

catkin_package()

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

add_executable(task_node
  src/task_manager.cpp
  src/main_node.cpp
)

target_link_libraries(task_node
  ${catkin_LIBRARIES}
)
```

------

## 3. 核心知识点回顾

1. **异步生存期**：通过 `spinner.start()`，ROS 回调在后台线程运行。当 `stage1Callback` 被触发时，它修改 `stage1_triggered_` 并 `notify_one`，主线程才得以从 `cv_stage1_.wait` 中醒来。
2. **锁的切换**：在 `executeWorkflow` 中，`unique_lock` 会在 `wait` 期间自动释放锁，允许回调函数获取锁并修改状态。
3. **安全性**：使用 `[this]{ return stage1_triggered_; }` 是最安全的做法，它能完美处理信号丢失或虚假唤醒。